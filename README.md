# EntropyHandleLifecycle

Understanding handles and symbolic execution with EntropyOracle

## üöÄ Quick Start

1. **Clone this repository:**
   ```bash
   git clone https://github.com/zacnider/fhevm-example-handles-handlelifecycle.git
   cd fhevm-example-handles-handlelifecycle
   ```

2. **Install dependencies:**
   ```bash
   npm install --legacy-peer-deps
   ```

3. **Setup environment:**
   ```bash
   npm run setup
   ```
   Then edit `.env` file with your credentials:
   - `SEPOLIA_RPC_URL` - Your Sepolia RPC endpoint
   - `PRIVATE_KEY` - Your wallet private key (for deployment)
   - `ETHERSCAN_API_KEY` - Your Etherscan API key (for verification)

4. **Compile contracts:**
   ```bash
   npm run compile
   ```

5. **Run tests:**
   ```bash
   npm test
   ```

6. **Deploy to Sepolia:**
   ```bash
   npm run deploy:sepolia
   ```

7. **Verify contract (after deployment):**
   ```bash
   npm run verify <CONTRACT_ADDRESS>
   ```

**Alternative:** Use the [Examples page](https://entrofhe.vercel.app/examples) for browser-based deployment and verification.

---

## üìã Overview

@title EntropyHandleLifecycle
@notice Understanding handles and symbolic execution with EntropyOracle
@dev Educational example explaining handles and their lifecycle with EntropyOracle integration
This example explains:
- What are handles?
- How handles are generated
- Symbolic execution in FHEVM
- Handle lifecycle and permissions
- EntropyOracle handle management
Handles:
- Handles are references to encrypted values
- Generated by FHEVM SDK when encrypting values
- Used to reference encrypted data in contracts
- Handles are not the actual encrypted data, just references
- EntropyOracle returns handles for encrypted entropy
Symbolic Execution:
- FHEVM uses symbolic execution to track encrypted values
- Handles represent encrypted values symbolically
- Operations on handles are tracked symbolically
- Actual decryption happens off-chain

@notice Constructor - sets EntropyOracle address
@param _entropyOracle Address of EntropyOracle contract

@notice Request entropy (returns a handle)
@param tag Unique tag for this request
@return requestId Request ID from EntropyOracle

@notice Store encrypted value (handle)
@param encryptedInput Encrypted input with handle
@param inputProof Input proof
@dev
Handle Lifecycle:
1. User encrypts value off-chain ‚Üí generates handle
2. Handle sent to contract via externalEuint64
3. Contract converts to internal euint64 (still a handle)
4. Contract stores handle in state
5. Handle can be used in FHE operations
6. Handle can be returned for off-chain decryption

@notice Use handle in FHE operation
@dev Demonstrates using stored handle in FHE operations
@return Result of FHE operation (also a handle)

@notice Get stored handle
@return Handle to encrypted value
@dev Returns handle, not decrypted value
@dev User must decrypt off-chain using FHEVM SDK

@notice Use entropy handle in FHE operation
@param requestId Request ID from requestEntropy()
@dev Demonstrates using entropy handle in FHE operations
@return Result of FHE operation (also a handle)

@notice Check if initialized

@notice Get EntropyOracle address



## üîê Zama FHEVM Usage

This example demonstrates the following **Zama FHEVM** features:

### Zama FHEVM Features Used

- **ZamaEthereumConfig**: Inherits from Zama's network configuration
  ```solidity
  contract MyContract is ZamaEthereumConfig {
      // Inherits network-specific FHEVM configuration
  }
  ```

- **FHE Operations**: Uses Zama's FHE library for encrypted operations
  - `FHE.add()` - Zama FHEVM operation
  - `FHE.sub()` - Zama FHEVM operation
  - `FHE.mul()` - Zama FHEVM operation
  - `FHE.eq()` - Zama FHEVM operation
  - `FHE.xor()` - Zama FHEVM operation

- **Encrypted Types**: Uses Zama's encrypted integer types
  - `euint64` - 64-bit encrypted unsigned integer
  - `externalEuint64` - External encrypted value from user

- **Access Control**: Uses Zama's permission system
  - `FHE.allowThis()` - Allow contract to use encrypted values
  - `FHE.allow()` - Allow specific user to decrypt
  - `FHE.allowTransient()` - Temporary permission for single operation
  - `FHE.fromExternal()` - Convert external encrypted values to internal

### Zama FHEVM Imports

```solidity
// Zama FHEVM Core Library - FHE operations and encrypted types
import {FHE, euint64, externalEuint64} from "@fhevm/solidity/lib/FHE.sol";

// Zama Network Configuration - Provides network-specific settings
import {ZamaEthereumConfig} from "@fhevm/solidity/config/ZamaConfig.sol";
```

### Zama FHEVM Code Example

```solidity
// Using Zama FHEVM's encrypted integer type
euint64 private encryptedValue;

// Converting external encrypted value to internal (Zama FHEVM)
euint64 internalValue = FHE.fromExternal(encryptedValue, inputProof);
FHE.allowThis(internalValue); // Zama FHEVM permission system

// Performing encrypted operations using Zama FHEVM
euint64 result = FHE.add(encryptedValue, FHE.asEuint64(1));
FHE.allowThis(result);
```

### Zama FHEVM Concepts Demonstrated

1. **Encrypted Arithmetic**: Using Zama FHEVM to encrypted arithmetic
2. **Encrypted Comparison**: Using Zama FHEVM to encrypted comparison
3. **External Encryption**: Using Zama FHEVM to external encryption
4. **Permission Management**: Using Zama FHEVM to permission management
5. **Entropy Integration**: Using Zama FHEVM to entropy integration

### Learn More About Zama FHEVM

- üìö [Zama FHEVM Documentation](https://docs.zama.org/protocol)
- üéì [Zama Developer Hub](https://www.zama.org/developer-hub)
- üíª [Zama FHEVM GitHub](https://github.com/zama-ai/fhevm)


## üîç Contract Code

```solidity
// SPDX-License-Identifier: BSD-3-Clause-Clear
pragma solidity ^0.8.27;

import {FHE, euint64, externalEuint64} from "@fhevm/solidity/lib/FHE.sol";
import {ZamaEthereumConfig} from "@fhevm/solidity/config/ZamaConfig.sol";
import "./IEntropyOracle.sol";

/**
 * @title EntropyHandleLifecycle
 * @notice Understanding handles and symbolic execution with EntropyOracle
 * @dev Educational example explaining handles and their lifecycle with EntropyOracle integration
 * 
 * This example explains:
 * - What are handles?
 * - How handles are generated
 * - Symbolic execution in FHEVM
 * - Handle lifecycle and permissions
 * - EntropyOracle handle management
 * 
 * Handles:
 * - Handles are references to encrypted values
 * - Generated by FHEVM SDK when encrypting values
 * - Used to reference encrypted data in contracts
 * - Handles are not the actual encrypted data, just references
 * - EntropyOracle returns handles for encrypted entropy
 * 
 * Symbolic Execution:
 * - FHEVM uses symbolic execution to track encrypted values
 * - Handles represent encrypted values symbolically
 * - Operations on handles are tracked symbolically
 * - Actual decryption happens off-chain
 */
contract EntropyHandleLifecycle is ZamaEthereumConfig {
    // Entropy Oracle interface
    IEntropyOracle public entropyOracle;
    
    euint64 private encryptedValue;
    bool private initialized;
    
    // Track entropy requests
    mapping(uint256 => bool) public entropyRequests;
    
    event HandleStored(address indexed user);
    event HandleUsed();
    event EntropyRequested(uint256 indexed requestId, address indexed caller);
    event EntropyHandleUsed(uint256 indexed requestId);
    
    /**
     * @notice Constructor - sets EntropyOracle address
     * @param _entropyOracle Address of EntropyOracle contract
     */
    constructor(address _entropyOracle) {
        require(_entropyOracle != address(0), "Invalid oracle address");
        entropyOracle = IEntropyOracle(_entropyOracle);
    }
    
    /**
     * @notice Request entropy (returns a handle)
     * @param tag Unique tag for this request
     * @return requestId Request ID from EntropyOracle
     */
    function requestEntropy(bytes32 tag) external payable returns (uint256 requestId) {
        require(msg.value >= entropyOracle.getFee(), "Insufficient fee");
        requestId = entropyOracle.requestEntropy{value: msg.value}(tag);
        entropyRequests[requestId] = true;
        emit EntropyRequested(requestId, msg.sender);
        return requestId;
    }
    
    /**
     * @notice Store encrypted value (handle)
     * @param encryptedInput Encrypted input with handle
     * @param inputProof Input proof
     * @dev 
     * Handle Lifecycle:
     * 1. User encrypts value off-chain ‚Üí generates handle
     * 2. Handle sent to contract via externalEuint64
     * 3. Contract converts to internal euint64 (still a handle)
     * 4. Contract stores handle in state
     * 5. Handle can be used in FHE operations
     * 6. Handle can be returned for off-chain decryption
     */
    function storeHandle(
        externalEuint64 encryptedInput,
        bytes calldata inputProof
    ) external {
        require(!initialized, "Already initialized");
        
        // Step 1: Convert external handle to internal handle
        // The handle is a reference, not the actual encrypted data
        euint64 internalHandle = FHE.fromExternal(encryptedInput, inputProof);
        
        // Step 2: Grant contract permission to use this handle
        // This is required for FHE operations
        FHE.allowThis(internalHandle);
        
        // Step 3: Store handle in contract state
        // The handle is stored, not the actual encrypted value
        encryptedValue = internalHandle;
        initialized = true;
        
        emit HandleStored(msg.sender);
    }
    
    /**
     * @notice Use handle in FHE operation
     * @dev Demonstrates using stored handle in FHE operations
     * @return Result of FHE operation (also a handle)
     */
    function useHandle() external returns (euint64) {
        require(initialized, "Not initialized");
        
        // Use stored handle in FHE operation
        // The operation is performed symbolically
        euint64 one = FHE.asEuint64(1);
        euint64 result = FHE.add(encryptedValue, one);
        
        // Result is also a handle (not decrypted value)
        emit HandleUsed();
        
        return result;
    }
    
    /**
     * @notice Get stored handle
     * @return Handle to encrypted value
     * @dev Returns handle, not decrypted value
     * @dev User must decrypt off-chain using FHEVM SDK
     */
    function getHandle() external view returns (euint64) {
        require(initialized, "Not initialized");
        return encryptedValue;
    }
    
    /**
     * @notice Use entropy handle in FHE operation
     * @param requestId Request ID from requestEntropy()
     * @dev Demonstrates using entropy handle in FHE operations
     * @return Result of FHE operation (also a handle)
     */
    function useEntropyHandle(uint256 requestId) external returns (euint64) {
        require(initialized, "Not initialized");
        require(entropyRequests[requestId], "Invalid request ID");
        require(entropyOracle.isRequestFulfilled(requestId), "Entropy not ready");
        
        // Get entropy handle from oracle
        euint64 entropyHandle = entropyOracle.getEncryptedEntropy(requestId);
        FHE.allowThis(entropyHandle);
        
        // Use entropy handle in FHE operation
        euint64 one = FHE.asEuint64(1);
        FHE.allowThis(one);
        euint64 result = FHE.add(encryptedValue, entropyHandle);
        FHE.allowThis(result);
        
        entropyRequests[requestId] = false;
        emit EntropyHandleUsed(requestId);
        emit HandleUsed();
        
        return result;
    }
    
    /**
     * @notice Check if initialized
     */
    function isInitialized() external view returns (bool) {
        return initialized;
    }
    
    /**
     * @notice Get EntropyOracle address
     */
    function getEntropyOracle() external view returns (address) {
        return address(entropyOracle);
    }
}

```

## üß™ Tests

See [test file](./test/EntropyHandleLifecycle.test.ts) for comprehensive test coverage.

```bash
npm test
```


## üìö Category

**handles**



## üîó Related Examples

- [All handles examples](https://github.com/zacnider/entrofhe/tree/main/examples)

## üìù License

BSD-3-Clause-Clear
